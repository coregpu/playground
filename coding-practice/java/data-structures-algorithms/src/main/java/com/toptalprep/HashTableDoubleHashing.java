package com.toptalprep;

/**
 * Hash table implementation that uses double hashing to resolve
 * key collisions.
 *
 * Linear and quadratic probing both have the limitation that the
 * probe sequence is identical for every key that hashes to the
 * same array index. The reason for that is that the probe offset
 * is independent of the key itself.
 *
 * Double hashing tackles this issue by making the probe offset
 * the function of the key as well. The complete hash function
 * used in double hashing has the following form:
 *
 * f(k, i) = [h1(k) + i*h2(k)] % m
 *
 * where h1(k) is the primary hash function, h2(k) is the secondary
 * hash function used to produce the probe offset for the key, i is
 * the number of probed indices and m is the array length. The primary
 * hash function used by {@link HashTableBase} is:
 *
 * h1(k) = hash(k) % m
 *
 * Note that h2(k) must be relatively prime to the array size m (that is
 * array size m must not be divisible by h2(k)), for the entire table to
 * be searched for i=0,...,m-1. To see why this is important, assume that
 * m=15, h1(k) = 0 and h2(k) = 5. The sequence of array indices that would
 * be probed is:
 *
 * f(k, 0) = 0
 * f(k, 1) = 5
 * f(k, 2) = 10
 * f(k, 3) = 0
 * f(k, 4) = 5
 * f(k, 5) = 10
 *
 * This sequence keeps repeating itself, so only 3 array indices will get
 * probed. Assume now that h2(k) = 14 which is relatively prime to m. The
 * following sequence is generated:
 *
 * f(k, 0) = 0
 * f(k, 1) = 14
 * f(k, 2) = 13
 * f(k, 3) = 12
 * f(k, 4) = 11
 *
 * and so on. As h2(k) is relatively prime to m, it can never divide it evenly
 * so the sequence of indices will not start repeating itself for i=0,...,m-1.
 * This hash table implementation uses the following h2(k) function:
 *
 * h2(k) = 1 + (hash(k) % (m-1))
 *
 * If array size m is prime the value generated by h2(k) will always be relatively
 * prime to m, as max(h2(k)) = m - 1 (when hash(k) % (m-1) evaluates to m-2). Hence,
 * the complete hashing function used by this class is:
 *
 * f(k, i) = {h1(k) + i*[1 + (hash(k) % (m-1))]} % m
 *         = {h1(k) + i + i*[hash(k) % (m-1)]} % m
 *
 * Instead of computing f(k, i) from scratch for every i, we can compute
 * f(k, i) as a function of f(k, i-1):
 *
 * f(k, i) - f(k, i-1) = {h1(k) + i + i*[hash(k) % (m-1)] - h1(k) - (i-1) - (i-1)*[hash(k) % (m-1)]} % m
 *                     = i + i*[hash(k) % (m-1)] - i + 1 -i*[hash(k) % (m-1)] + [hash(k) % (m-1)]} % m
 *                     = {1 + [hash(k) % (m-1)]} % m
 *                     = 1 + [hash(k) % (m-1)] (as [hash(k) % (m-1)] < m)
 *
 * and thus: f(k, i) = f(k, i-1) + 1 + [hash(k) % (m-1)]. Note that f(k, 0) = h1(k) % m.
 */
public class HashTableDoubleHashing<KeyT, ValueT> extends HashTableOpenAddressing<KeyT, ValueT> {
	/**
	 * Constructs a HashTableDoubleHashing instance with initial capacity
	 * of 16 elements and load factor of 0.75.
	 */
	public HashTableDoubleHashing() {
		super(13, 0.75f);
	}
	
	/**
	 * Constructs a HashTableDoubleHashing instance with given initial capacity
	 * rounded up to a prime and load factor of 0.75.
	 *
	 * @param initial_capacity  The hash table's initial capacity that is rounded up
	 *                          to a prime.
	 *
	 * @throws IllegalArgumentException if initial_capacity is less or equal to zero.
	 */
	public HashTableDoubleHashing(int initial_capacity) throws IllegalArgumentException {
		super(roundToPrime(initial_capacity), 0.75f);
	}
	
	/**
	 * Constructs a HashTableDoubleHashing instance with given initial capacity rounded
	 * up to a prime of two and load factor.
	 *
	 * @param initial_capacity  The hash table's initial capacity that is rounded up
	 *                          to a prime.
	 * @param load_factor       The load factor determines the maximal occupancy of
	 *                          the table before it is re-sized. This value represents
	 *                          a percentage and falls within a range [0.0, 1.0].
	 *
	 * @throws IllegalArgumentException if initial_capacity is less or equal to zero
	 *         or load_factor is negative or greater than 1.0.
	 */
	public HashTableDoubleHashing(int initial_capacity, float load_factor)
			throws IllegalArgumentException {
		super(roundToPrime(initial_capacity), load_factor);
	}
	
	/**
	 * Find a prime p such that p >= value.
	 *
	 * Note that for every n > 1 there is always at least one prime p such that
	 * n < p < 2n. Hence the method will never check any number outside of the
	 * [n, 2n) range. The method uses naive prime testing algorithm - it checks
	 * whether given number n is divisible by 2 and if not proceeds to check if
	 * it divisible by any odd number in the range [3, n/2). This shouldn't be an
	 * issue though as the prime is usually found very quickly, and this method
	 * will be invoked rarely.
	 *
	 * @note The method returns 0 if value passed in is 0. This is because using
	 * 0 as the table is is illegal and {@link HashTableBase#HashTableBase(int, float)}
	 * will throw an exception when zero is passed in for initial capacity.
	 *
	 * @param value  The value to round to the prime number.
	 *
	 * @return  Returns prime p such that p >= value.
	 */
	private static int roundToPrime(int value) {
		if (value == 0) {
			return 0;
		}
		
		if (value == 2) {
			// Handle the corner case of the only even prime
			return value;
		}
		
		if (value % 2 == 0) {
			// 2 is the only even prime number. We don't want to test the
			// even numbers, so add one to start testing with the odd value.
			++value;
		}
		
		boolean prime_found = false;
		while (!prime_found) {
			prime_found = true;
			
			// We only need to check the odd numbers from now on as we
			// know that value is an odd number. We also don't need to
			// check beyond value / 2 because no integer x is divisible
			// by an integer y if y > x/2.
			for (int i = 3; i < value / 2; i += 2) {
				if (value % i == 0) {
					// Next iteration will test the next odd number
					value += 2;
					prime_found = false;
					break;
				}
			}
		}
		return value;
	}
	
	/**
	 * @see HashTableOpenAddressing#nextProbeOffset(long, int)
	 *
	 * As showed in {@link HashTableDoubleHashing}, the next array index to
	 * probe is entirely determined by the key hash. I.e. if the last probed
	 * array index was x, the next array index to probe is computed as
	 * (x + 1 + hash(k) % (m-1)). Thus, this method returns (1 + hash(k) % (m-1))
	 * as the probe offset (note that offset doesn't depend on the number of
	 * array indices probed, it only depends on the key).
	 */
	protected int nextProbeOffset(long key_hash, int probed_indices_count) {
		// It integer cast below is safe, as the resulting value can never be
		// greater than Integer.MAX_VALUE - 2. Hence, adding 1 to that value
		// also won't cause integer overflow.
		return 1 + (int)(key_hash % (m_array.length - 1));
	}
	
	/**
	 * @see HashTableOpenAddressing#computeArraySize(int)
	 *
	 * The array length is required to be a prime number this hash table
	 * implementation. Thus, the requested size is rounded up to the prime
	 * to form the actual size.
	 */
	protected int computeArraySize(int requested_size) throws ArithmeticException {
		int actual_size = roundToPrime(requested_size);
		if (actual_size < 0) {
			throw new ArithmeticException("Rounding the size to a prime causes overflow");
		}
		return actual_size;
	}
}
