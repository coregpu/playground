/**
 * This component uses component local styles (defined in product-table.component.scss).
 * These styles are applied only to this component's template and will not affect
 * CSS styling of any ascendant or descendant components. This works by applying
 * styles to special attributes which Angular adds to all HTML elements in component's
 * template.
 *
 * To illustrate, let's assume the following CSS styles:
 *
 * div {
 *   background-color: blue;
 * }
 *
 * and the following template:
 *
 * <div>
 *   <div>
 *     <p>
 *       Some text.
 *     </p>
 *     <div>A div</div>
 *   </div>
 * </div>
 *
 * Angular will produce the following <style> element to page's HEAD:
 *
 * <style>
 *   div[_ngcontent-pod-c123] {
 *     background-color: blue;
 *   }
 * </style>
 *
 * where `_ngcontent-pod-c123` is an unique identifier generated by Angular guaranteed
 * not to clash with any other such IDs. This means that these styles are applied only
 * to elements that have this attribute. Finally, Angular modifies the template by adding
 * this ID as attribute to all template elements:
 *
 * <div _ngcontent-pod-c123="">
 *   <div _ngcontent-pod-c123="">
 *     <p _ngcontent-pod-c123="">
 *       Some text.
 *     </p>
 *     <div _ngcontent-pod-c123="">A div</div>
 *   </div>
 * </div>
 *
 * As no other template uses this ID, the styles can only ever be applied locally to
 * the template whose component defines the styles.
 *
 * This is know as a view encapsulation behavior and what Angular is doing is emulating
 * a feature known as Shadow DOM, which allows part of the DOM to be isolated so that
 * Javascript and styles are applied to one part of the HTML document only. The reason
 * Angular emulates this behavior is that the native support for Shadow DOM is limited.
 * However, Angular allows changing the view encapsulation behavior of the component
 * using the ViewEncapsulation enum which has the following values:
 *
 * - ViewEncapsulation.Emulated - this is the behavior described above which works in
 *   all browsers supported by Angular.
 * - ViewEncapsulation.Native - Angular uses browsers native support for Shadow DOM.
 *   Only works if browser supports Shadow DOM natively or if polyfill is used.
 * - ViewEncapsulation.None - Angular will simply copy the component's styles to the
 *   <style> element in the HTML document without any modification. Normal CSS
 *   precedence rules will apply which can lead to various issues where styles
 *   from different components interfere with one another.
 *
 * For more info on Shadow DOM:
 * - https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM
 * - https://developers.google.com/web/fundamentals/web-components/shadowdom?hl=en
 */

import {
  Component, Input, ViewEncapsulation, Directive, ElementRef, ViewChildren, QueryList,
  AfterViewInit
} from "@angular/core";
import {Repository} from "../../repository.model";
import {Product} from "../../product.model";

/**
 * A simple directive whose purpose is to be queried using the @ViewChildren
 * decorator in the ProductTableComponent class.
 */
@Directive({
  selector: "[appSetTextColorInnerDir]"
})
export class SetTextColorInnerDirective {
  previousTextColorClass = "";
  hostElemClassList: DOMTokenList;

  constructor(hostElemRef: ElementRef) {
    this.hostElemClassList = (hostElemRef.nativeElement as HTMLElement).classList;
  }

  setTextColor(textColorBootstrapClass: string) {
    if (this.previousTextColorClass) {
      this.hostElemClassList.remove(this.previousTextColorClass);
    }
    this.hostElemClassList.add(textColorBootstrapClass);
    this.previousTextColorClass = textColorBootstrapClass;
  }
}

@Component({
  selector: "product-table",
  templateUrl: "product-table.component.html",

  /**
   * The styles from the following SCSS script are applied to this component's
   * template only.
   */
  styleUrls: ["product-table.component.scss"],

  /**
   * Just an example of explicitly setting view encapsulation. The Emulated encapsulation
   * is anyways the default.
   */
  encapsulation: ViewEncapsulation.Emulated
})
export class ProductTableComponent implements AfterViewInit{
  /**
   * Input property used to pass in the data source to the component.
   */
  @Input()
  repository: Repository | undefined;

  /**
   * The @ViewChildren decorator is used by the components to query their
   * template for other components or directives knows as view children.
   * It is similar to the @ContentChildren decorator which is illustrated
   * in attribute-directives/content-children.directive.ts with one notable
   * difference: @ContentChildren and @ContentChild decorators query the
   * contents of the host element where the directive using this decorator
   * is applied. This excludes the contents of the component's template.
   * On other hand, @ViewChildren and @ViewChild decorators query the
   * component's template ignoring the content of the component's host
   * element (content projected using ng-content).
   *
   * @note A view child of a component's host element is any element within
   * the component's template. This excludes the content projected using the
   * ng-content, meaning that the content of the host element is not queried
   * by @ViewChild and @ViewChildren decorators (this is what @ContentChild
   * and @ContentChildren decorators are used for).
   *
   * @ViewChild decorator returns the very first matching component or directive
   * (if it finds any).
   *
   * @ViewChild and @ViewChildren can also search the component templates by using
   * the template reference variable name.
   */
  @ViewChildren(SetTextColorInnerDirective)
  // Set once ngAfterViewInit is invoked so can ignore TS warning safely
  // @ts-ignore
  childrenDirectives: QueryList<SetTextColorInnerDirective>;

  /**
   * Angular executes the view query (to find the matching view children) just
   * before the ngAfterViewInit hook is invoked. One cannot use the result of
   * the view query (the `childrenDirectives` property) before.
   *
   * The corresponding hook used for content queries (@ContentChild and
   * @ContentChildren) is ngAfterContentInit as illustrated in content-child.component.ts
   * and content-children.component.ts.
   */
  ngAfterViewInit(): void {
    // Immediately update the text color for the children directives (or
    // rather their corresponding host elements)
    this.updateChildrenDirectives();

    // Register the callback to update the element's background when content
    // query changes (i.e. matching directives added and/or removed from the
    // host element's content)
    this.childrenDirectives.changes.subscribe(() => {
      // This callback is executed as part of the content update after Angular
      // has evaluated the data bindings (including the data bindings for the
      // child directives). Hence, making changes that would result in data
      // bindings returning different values after this callback returns is
      // prohibited by Angular and will cause an error in Debug runs. Starting
      // another content update must not happen until the one in progress has
      // been completed, hence we're performing the update asynchronously
      // with a timeout.
      setTimeout(() => {
        this.updateChildrenDirectives();
      }, 0);
    });
  }

  updateChildrenDirectives() {
    if (this.childrenDirectives) {
      this.childrenDirectives.forEach(item => {
        item.setTextColor("text-danger");
      });
    }
  }

  getProduct(key: number): Product | undefined {
    return this.repository?.getProduct(key) || undefined;
  }

  getProducts(): Product[] {
    return this.repository?.getProducts() || [];
  }

  deleteProduct(key: number) {
    this.repository?.deleteProduct(key);
  }
}

