/**
 * Structural directive implementing the same functionality as the built-in
 * ngFor directive. Before explaining how the directive works, here are some needed
 * definitions:
 *
 * - ViewContainerRef - is the the container of views which basically corresponds
 *   to the ng-template element. Directive receives an instance of this container
 *   as a constructor argument (via dependency injection) and uses it to create,
 *   remove and move views
 * - EmbeddedViewRef/ViewRef - represents HTML content generated by the directive
 *   in a single iteration. Directive will create as many views as there are elements
 *   in the collection that it iterates over.
 * - TemplateRef<> - represents the content of the ng-template element. This template
 *   contains all the information needed to build the views using ViewContainerRef.
 *   Passed to the directive as a constructor argument.
 * - ViewContainerRef.createEmbeddedView() - builds the view based on the provided
 *   TemplateRef<> object. The method also accepts a so called context object whose
 *   properties can be used to tail the view generation - see the section on
 *   context variables to see how these context variables are used in the template.
 *
 * ---------- USAGE ----------
 *
 * <ng-template [appForDirOf]="aCollection" let-item let-i="index" let-odd="odd">
 *   <div></div> <!-- Using DIV here just as an example -->
 * </ng-template>
 *
 * or in compact form (also called star notation):
 *
 * <div *appForDir="let item of aCollection; let i = index; let odd = odd"></div>
 *
 * @note In order to be able to use the compact form with structural directives
 * that iterate over collection, directive's name must have the `Of` suffix. When
 * Angular encounters the `*appForDir="let item of aCollection"` it expects to
 * find a directive whose selector matches the `appForDirOf` attribute. If it does,
 * it knows that it can expand this compact notation into the extended one above.
 *
 * ---------- CONTEXT VARIABLES ----------
 *
 * The template variables defined with `let-item let-i="index"` syntax are so-called context
 * variables. These variables allow to tailor each of the views generated by the directive
 * using the built-in variables provided by the directive. The `appForDirOf` directive
 * (just like the ngForOf built-in) supports following context variables:
 *
 * $implicit, index, first, last, even and odd
 *
 * The way this works is that when Angular encounters these variables in the template,
 * it includes them in the TemplateRef<> object and it expects that an object with
 * these properties is provided at view generation time (i.e. when createEmbeddedView
 * is called). In our example
 *
 * <ng-template [appForDirOf]="aCollection" let-item let-i="index" let-odd="odd">
 *
 * Angular expects an object with the following properties to be passed as context
 * to createEmbeddedView:
 *
 * { $implicit: ..., index: ..., odd: ... }
 *
 * Angular will then assign the property `$implicit` to template variable `item`, `index`
 * to `i` and `odd` to template variable `odd`. Note how the context property named
 * `$implicit` is assigned to the template variable whose name is not provided:
 *
 * let-item
 *
 * All the other template variables have names i.e. let-i="index", so Angular will
 * assign context property with this name (i.e. index) to the template variable.
 *
 * ---------- CHANGE DETECTION AND DOM UPDATE ----------
 *
 * The directive has an input property named `collection` used to pass in the collection
 * of data items that directive will iterate over and generate views for. Angular does
 * not detect changes within collections automatically which means that ngOnChanges method
 * is not invoked when collection content changes. This is due to performance
 * reasons - in order for Angular check collections for changes, it would have to scan
 * the collection linearly at each check changes cycle. As the number of these
 * cycles can be very high in complex applications (i.e. mouse click, element getting
 * focus, text input and many other events), it is unfeasible to automatically
 * check for collection changes. Hence, iterating directives such as this one must
 * track collection changes on its own by implementing the ngDoCheck method. To support
 * change detection in collections, Angular provides the following classes:
 *
 * - IterableDiffers - a repository of different diffing strategies. Used to find the most
 *   suitable diffing strategy for a given iterable. Application can also extend the
 *   repository with new strategies.
 * - IterableDiffingFactory - IterableDiffers returns a factory corresponding to the most
 *   suitable diffing strategy for a given iterable. Factory is then used to create
 *   instance of the strategy. User can supply a custom TrackByFunction when creating
 *   a strategy, in which case the diffing strategy uses this function to determine if
 *   to objects have the same identity (instead of the default Object.is identity comparison).
 *   See more in the Custom TrackByFunction section below.
 * - IterableDiffer<> - the diffing strategy. Used to compare the previous version of the
 *   collection with the current one.
 * - IterableChanges<> - represents changes between the previous and the current state of
 *   the collection returned by IterableDiffer.diff() method. See bellow for the description
 *   of methods used to access the changes as well as how directive updates the DOM based
 *   on these changes.
 * - IterableChangeRecord<> - changes tracked by IterableChanges<> are exposed via this
 *   class. It contains the following properties:
 *     - currentIndex - the index of the item in the current collection. This is NULL if
 *       item has been removed.
 *     - previousIndex - the index of the item in the previous collection. This is NULL if
 *       this is a newly added item.
 *     - item - the collection item this change record is tracking
 *     - trackById - the track by identity computed by the TrackByFunction. By default, this
 *       is the item (object) itself. If custom TrackBy function is provided, that this is
 *       set to the value returned by that function for the given collection item.
 *
 * Directive will diff the current and previous state of the collection on each change
 * detection cycle (when ngDoCheck directive method is invoked). If there are changes, it
 * will proceed as follows:
 *
 * - Build an array of views corresponding to items that were removed from the collection
 *   as well as an array of views for items that changed their position within the collection.
 *   IterableChanges.forEachRemovedItem()/IterableChanges.forEachMovedItem() methods are used
 *   to build an array of views corresponding to removed/moved items. The views themselves are
 *   obtained using the ViewContainerRef.get() method using the IterableChangeRecord.previousIndex
 *   index, which points to the index that the view has in the container.
 *
 *   The reason for building these two arrays is that once views are removed and/or moved
 *   within the ViewContainerRef container, the IterableChangeRecord.previousIndex might no
 *   longer point to the correct views. Calculating the correct view index after the container
 *   is modified is tricky, so we just cache the views before we start modifying the container.
 *
 * - Remove views corresponding to items removed from the collection. This is done using the
 *   ViewContainerRef.remove() method, passing the index of the view to be removed.
 *
 *   Note, however, that one cannot use the IterableChangeRecord.previousIndex as the index
 *   when removing the views. Removing views from the container might change the position
 *   within the container of other views to be removed, rendering IterableChangeRecord.previousIndex
 *   useless. Thus, index of each view to be removed is queried with ViewContainerRef.index()
 *   method and that index is passed to ViewContainerRef.remove() to remove the view at the
 *   given index.
 *
 * - Move views corresponding to items that changed their place within the collection. This
 *   is done using the ViewContainerRef.move() item providing the view to be moved as well
 *   as the new index within the view container. The index is obtained from the
 *   IterableChangeRecord.currentIndex which determines new place for the corresponding
 *   item within the collection.
 *
 *   Note that context data for the given view must be updated too as a result of changed
 *   view position. Otherwise, context variables would no longer match the view (e.g. index
 *   context variable would not match the new view index).
 *
 * - For each new item added to the collection, a view is created and added to the view
 *   container using the ViewContainerRef.createEmbeddedView() method providing it with
 *   the context object as well as the index where the view will be inserted at. This
 *   index is determined by IterableChangeRecord.currentIndex.
 *
 * ---------- OBJECT IDENTITY CHANGE ----------
 *
 * When diffing previous and current state of the collection Angular uses Object.is() method
 * to determined whether two objects are identical. However, when Object.is() method is applied
 * to objects (as opposed to JS primitive types such as number or string), it will return false
 * whenever the two instances don't point to the same object in memory. To illustrate,
 *
 * Object.is({ a: 2 }, { a: 2 }) yields false because these are two different instances, even
 * though objects represent exactly the same data. Assuming that the collection used by the
 * appForDirOf directive contains objects, if we would replace each object in the collection
 * with a new object holding exactly the same data, IterableDiffer.diff() would report that
 * all items of the previous collection have been removed and that that many new items have been
 * added to the collection (due to Object.is() returning false for every pair of objects in
 * the old and new collection). The directive would then destroy each view and create a new
 * view, even though no real data changes have occurred in the collection.
 *
 * This can cause a serious performance issue in apps where objects in the collection might
 * be often recreated as a result of data received from the server for instance. While objects
 * are recreated and their identity changes, the underlying data is often unchanged and hence
 * does not warrant destroying and creating a new view. A custom TrackByFunction is a way
 * to work around this.
 *
 * ---------- CUSTOM TRACKBY FUNCTION ----------
 *
 * Let's say we have a following Product class:
 *
 * class Product {
 *   constructor(private id: number, private name: string){}
 * }
 *
 * and that appForDirOf directive is used with a collection of Product objects. Object.is()
 * method returns false for the following:
 *
 * Object.is(new Product(1, "product"), new Product(1, "product"))
 *
 * as these two Product instances point to different objects in memory. However, these two
 * objects represent the same data and we know that there can ever be only one instance of
 * Product with the ID 1. Hence, the directive has a input property appForDirTrackBy that
 * can be used to provide a custom function that will be used to generate an unique identity
 * for the given object. One could pass in the following function:
 *
 * getKey(index: number, product: Product): number {
 *   return product.id;
 * }
 *
 * This function is passed to the IterableDiffingFactory.create() method when creating the
 * IterableDiffer<> instance, which will than apply the custom function to obtain the
 * object identity before comparing two object identities using Object.is() method. As
 * our getKey function returns a number, Object.is() will end up comparing numbers and
 * any two Product instances with the same ID will be considered identical objects.
 *
 * Let's say that application recreates all the Products in the collection as a result
 * of the server response, but all the Products instances represent exactly the same
 * data as before. With the custom getKey TrackBy function in place, the IterableDiffer.diff()
 * wouldn't detect any changes as none of the Product IDs have changed. Accordingly,
 * directive would not perform any DOM manipulation (which is not necessary as data
 * remains unchanged).
 *
 * Note that the IterableChanges returned by IterableDiffer.diff() also has a method
 * called forEachIdentityChange(). This method iterates over each object identity
 * change in the collection, and these changes are tracked only when a custom TrackBy
 * function is provided. If identities returned by the custom TrackBy function are
 * equal but Object.is() returns false when objects themselves are compared (hence
 * they represent two different instances), IterableDiffer.diff() marks that as object
 * identity changes. appForDirOf does not process these changes as no DOM modifications
 * are needed for them (underlying data has remained unchanged, as guaranteed by the
 * custom TrackBy function).
 */

import {
  Directive,
  Input,
  ViewContainerRef,
  TemplateRef,
  IterableDiffer,
  IterableDiffers,
  IterableChanges,
  EmbeddedViewRef,
  TrackByFunction
} from "@angular/core";


@Directive({
  selector: "[appForDirOf]"
})
export class ForDirective {
  /**
   * Assigned on ngOnInit, hence is guaranteed to be defined.
   */
  // @ts-ignore
  private differ: IterableDiffer<any>;

  /**
   * ViewContainerRef object corresponds to the ng-template element and is used to
   * insert content (or views) in the HTML document.
   */
  constructor(private container: ViewContainerRef,
              private template: TemplateRef<ForDirectiveContext>,
              private differs: IterableDiffers) {
  }

  /**
   * Input property used to pass in the collection the directive will iterate over.
   */
  @Input("appForDirOf")
  collection: any;

  /**
   * Input property used to pass in a custom TrackBy function, used to uniquely
   * identify objects in the collection.
   */
  @Input()
  appForDirTrackBy: TrackByFunction<any> | undefined;

  ngOnInit() {
    // Find the IterableDiffers factory and create the IterableDiffer strategy used
    // to track the collection changes
    this.differ = this.differs.find(this.collection).create(this.appForDirTrackBy);
  }

  ngDoCheck() {
    // Find differences between the previous and current state of the collection.
    // Note that this.differ is assigned in ngOnInit and is definitely not undefined.
    const changes: IterableChanges<any> | null =  this.differ.diff(this.collection);
    if (changes) {
      console.log("CHANGES IN COLLECTION DETECTED");

      // Build an array of views which have to be moved and/or removed. Once we start
      // moving and/or removing views from the container, the record.previousIndex might
      // no longer point to the correct view. Figuring out the correct previous index is
      // tricky, so we instead simply cache the view handles beforehand.
      const viewsToMove: Array<{ view: EmbeddedViewRef<ForDirectiveContext>, currentIndex: number }> = [];
      changes.forEachMovedItem(record => {
        // record.previousIndex and record.currentIndex are guaranteed not to be null for moved items
        // The returned view is guaranteed to be instance of EmbeddedViewRef as views are added
        // using the createEmbeddedView method.
        viewsToMove.push({
          view: this.container.get(record.previousIndex as number) as EmbeddedViewRef<ForDirectiveContext>,
          currentIndex: record.currentIndex as number
        });
      });
      const viewsToRemove: Array<EmbeddedViewRef<ForDirectiveContext>> = [];
      changes.forEachRemovedItem(record => {
        viewsToRemove.push(this.container.get(record.previousIndex as number) as EmbeddedViewRef<ForDirectiveContext>);
      });

      let counter = 0;
      // Process the removed items. Note the need to search for view's index
      // instead of using record.previousIndex. This is because each view removal
      // might affect the index of views that will be removed afterwards, making
      // record.previousIndex useless.
      for (const view of viewsToRemove) {
        this.container.remove(this.container.indexOf(view));
        ++counter;
      }
      console.log(`Number of removed items: ${counter}`);

      counter = 0;
      // Process the moved items
      for (const view of viewsToMove) {
        // Move the view
        this.container.move(view.view, view.currentIndex);

        // Update the context object
        view.view.context.update(view.currentIndex as number, this.collection.length);
        ++counter;
      }
      console.log(`Number of moved items: ${counter}`);

      // Process added items
      counter = 0;
      changes.forEachAddedItem(record => {
        // Create and insert the new view at the correct index
        // record.currentIndex is guaranteed not to be null for added items
        this.container.createEmbeddedView(
          this.template,
          new ForDirectiveContext(record.item, record.currentIndex as number, this.collection.length),
          record.currentIndex as number
        );
        ++counter;
      });
      console.log(`Number of added items: ${counter}`);

      counter = 0;
      // Count the number of identity changes for logging purposes. We don't need to
      // perform any DOM manipulation as part of identity changes, as we know that
      // the underlying data has remained unchanged. Identity changes are produced only
      // if a custom TrackBy function has been provided to the directive.
      changes.forEachIdentityChange(record => {
        ++counter;
      });
      console.log(`Number of identity changes: ${counter}`);
      console.log();
    }
  }
}

class ForDirectiveContext {
  // @ts-ignore
  public first: boolean;
  // @ts-ignore
  public last: boolean;
  // @ts-ignore
  public even: boolean;
  // @ts-ignore
  public odd: boolean;

  constructor(public $implicit: any, public index: number, length: number) {
    this.update(this.index, length);
  }

  update(index: number, length: number) {
    this.index = index;
    this.first = index === 0;
    this.last = index === length - 1;
    this.even = index % 2 === 0;
    this.odd = !this.even;
  }
}
